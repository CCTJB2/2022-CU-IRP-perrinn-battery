#define S_FUNCTION_NAME cu_irp_perrinn__dy9058dqglo
#ifndef Matlab6
#define Matlab6
#endif
#ifndef Matlab51
#define Matlab51
#endif
#ifndef MatlabR13
#define MatlabR13
#endif
/* Initial values of inputs to be used during initialization */
static double u0_[1] = {0};

/* Variables for GenerateResultInNonDymosim.c if included */
#if !defined(DYMOLA_DSPACE) && !defined(RT) && !defined(NRT)
#define DYMOLABLOCK_RESULT
char* dymolaBlockResult = "cu_irp_perrinn__dy9058dqglo.mat";
#endif

#if defined(DYM2CCUR) && defined(OMP_DYMOLA)
 #include "ss2dym_rt_omp.c"
#else
 #include "ss2dym.c"
#endif
#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model CU_IRP_perrinn_battery.Electrical.Batteries.Electro_therml_3D.ECM_2RC
 Dymola Version 2019 (64-bit), 2018-05-31 translated this at Thu Aug 11 19:12:44 2022

   */

#include <matrixop.h>
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_readTableData_M(
  struct DymStruc0 tableID0_0, int  forceRead0_0, int  verboseRead0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.getTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative(noDerivative=tableAvailable)=Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue, Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1Ds.getTableValue;

  */
extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.readTableData
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Boolean forceRead(start = false) "= true: Force reading of table data; = false: Only read, if not yet read.";
input Boolean verboseRead "= true: Print info message; = false: No info message";
discrete output Real readSuccess "Table read success";

external "C" readSuccess = ModelicaStandardTables_CombiTable1D_read(tableID, forceRead, verboseRead);
annotation(Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1Ds.readTableData;

  */
extern double (ModelicaStandardTables_CombiTable1D_read)(void*, int , int );
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_readTableData_M(
  struct DymStruc0 tableID0_0, int  forceRead0_0, int  verboseRead0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.readTableData")
  {
    /* Declare outputs and temporaries */
    double   readSuccess0_0;
    readSuccess0_0=0;
    /* Start of real code */
    {
      readSuccess0_0 = (ModelicaStandardTables_CombiTable1D_read)(
        externalTable_[tableID0_0.id_0member].obj_, forceRead0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return readSuccess0_0;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init(tableName, fileName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
extern void* (ModelicaStandardTables_CombiTable1D_init)(const char* , 
  const char* , double  const *, size_t, size_t, int  const *, size_t, int );
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}
/* DSblock C-code: */

#define NX_    3
#define NX2_   0
#define NU_    1
#define NY_    4
#define NW_    29
#define NP_    17
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   2
#define MAXAuxStrLen_   500
#define NHash1_ 817499096
#define NHash2_ -109300080
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    54
#define SizePre_ 0
#define SizeEq_ 4
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 1
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="CU_IRP_perrinn_battery.Electrical.Batteries.Electro_therml_3D.ECM_2RC";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/jason/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_
#define DIRECT_FEED_THROUGH 1

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,20) = 1;
#endif
DYNSetAuxString(did_, "table", 0);
DYNSetAuxString(did_, "C:/Users/jason/OneDrive - The Hong Kong Polytechnic University/Cranfield Studies/4 Course Projects/IRP Battery/A123/A123_OCV_Discharge.mat",
   1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,23) = 2;
DYNX(W_,27) = 3;
DYNX(W_,22) = true;
DYNX(W_,24) = 1;
DYNX(W_,17) = 0;
DYNX(W_,2) = 0;
DYNX(W_,14) = 0;
DYNX(W_,16) = 0;
DYNX(W_,19) = 0;
DYNX(W_,13) = 0.0;
DYNX(W_,11) = 0.0;
DYNX(W_,15) = 0.0;
DYNX(W_,18) = 0.0;
DYNX(W_,12) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"table\", \"C:/Users/jason/OneDrive - The Hong Kong Polytechnic University/Cranfield Studies/4 Course Projects/IRP Battery/A123/A123_OCV_Discharge.mat\", DoD_OCV.table, DoD_OCV.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 0)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("table", "C:/Users/jason/OneDrive - The Hong Kong Polytechnic University/Cranfield Studies/4 Course Projects/IRP Battery/A123/A123_OCV_Discharge.mat",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( 
    &DYNX(W_,23), 1, 1), 1, 0, 0));
  DYNX(W_,25) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterConstantSection
DYNX(W_,28) = DYNX(DP_,15)*DYNX(DP_,16);
BoundParameterSection
InitialSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,2) = DYNX(DP_,11);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"table\", \"C:/Users/jason/OneDrive - The Hong Kong Polytechnic University/Cranfield Studies/4 Course Projects/IRP Battery/A123/A123_OCV_Discharge.mat\", DoD_OCV.table, DoD_OCV.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 0)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("table", "C:/Users/jason/OneDrive - The Hong Kong Polytechnic University/Cranfield Studies/4 Course Projects/IRP Battery/A123/A123_OCV_Discharge.mat",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( 
    &DYNX(W_,23), 1, 1), 1, 0, 0));
  DYNX(W_,25) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
DYNX(W_,26) = 0.0;
  {
    DYNX(W_,26) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.readTableData(\nDoD_OCV.tableID, \nfalse, \nDoD_OCV.verboseRead)")
      Modelica_Blocks_Tables_CombiTable1Ds_readTableData_M(DymStruc0_construct(
      (Integer)(DYNX(W_,25))), false, (Integer)(DYNX(DP_,9))));
    PopModelContext();
  }
InitialSection2
DYNX(W_,28) = DYNX(DP_,15)*DYNX(DP_,16);
DYNX(X_,2) = DYNX(DP_,11);
DYNX(X_,1) = DYNX(DP_,7);
DYNX(X_,0) = DYNX(DP_,3);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection
DYNX(W_,21) = divmacro(DYNX(X_,2),"columb_Counting.integrator.y",DYNX(W_,28),
  "columb_Counting.division.u2");
DYNX(Y_,1) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nDoD_OCV.tableID, \n1, \nDoD_OCV.u, \nDoD_OCV.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,25))), 1, DYNX(W_,21), DYNX(W_,26)));
PopModelContext();
DYNX(Y_,3) = DYNX(DP_,12)*DYNX(W_,21)+DYNX(DP_,13)*DYNX(DP_,14);
DYNX(W_,0) = DYNX(DP_,0)*DYNX(U_,0);
DYNX(W_,1) = DYNX(Y_,1)-DYNX(W_,0);
DYNX(W_,4) = DYNX(W_,1)-DYNX(X_,1);
DYNX(Y_,0) = DYNX(W_,4)-DYNX(X_,0);
DYNX(Y_,2) = DYNX(U_,0);

DynamicsSection
DYNX(F_,2) = DYNX(DP_,10)*DYNX(U_,0);
 /* Linear system of equations to solve. */
DYNX(W_,3) = RememberSimple_(DYNX(W_,3), 0);
SolveScalarLinearParametric(DYNX(DP_,1),"R1.R", DYNX(X_,1),"C1.vinternal", 
  DYNX(W_,3),"R1.i");
 /* End of Equation Block */ 

DYNX(W_,10) = DYNX(U_,0)-DYNX(W_,3);
 /* Linear system of equations to solve. */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 1);
SolveScalarLinearParametric( -DYNX(DP_,6)," -C1.C",  -DYNX(W_,10)," -C1.i", 
  DYNX(F_,1),"der(C1.vinternal)");
 /* End of Equation Block */ 

DYNX(W_,7) = DYNX(W_,4)-DYNX(Y_,0);
 /* Linear system of equations to solve. */
DYNX(W_,8) = RememberSimple_(DYNX(W_,8), 2);
SolveScalarLinearParametric(DYNX(DP_,5),"R2.R", DYNX(W_,7),"R2.v", DYNX(W_,8),
  "R2.i");
 /* End of Equation Block */ 

DYNX(W_,6) = DYNX(W_,10)+DYNX(W_,3)-DYNX(W_,8);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 3);
SolveScalarLinearParametric( -DYNX(DP_,2)," -C2.C",  -DYNX(W_,6)," -C2.i", 
  DYNX(F_,0),"der(C2.vinternal)");
 /* End of Equation Block */ 


AcceptedSection1

AcceptedSection2
DYNX(W_,5) = DYNX(W_,4)-DYNX(Y_,0);
DYNX(W_,9) = DYNX(W_,1)-DYNX(W_,4);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("R0.v", "Voltage drop between the two pins (= p.v - n.v) [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("R0.i", "Current flowing from pin p to pin n [A]", "I_demand", 1, 2,\
 0, 0)
DeclareAlias2("R0.p.v", "Potential at the pin [V]", "OCV_out", 1, 3, 1, 4)
DeclareAlias2("R0.p.i", "Current flowing into the pin [A]", "I_demand", 1, 2, 0,\
 132)
DeclareVariable("R0.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("R0.n.i", "Current flowing into the pin [A]", "I_demand", -1, 2, 0,\
 132)
DeclareParameter("R0.R", "Resistance [Ohm]", 0, 0.0015, 0.0,0.0,0.0,0,560)
DeclareAlias2("OCV.p.v", "Potential at the pin [V]", "OCV_out", 1, 3, 1, 4)
DeclareAlias2("OCV.p.i", "Current flowing into the pin [A]", "I_demand", -1, 2, 0,\
 132)
DeclareVariable("OCV.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("OCV.n.i", "Current flowing into the pin [A]", "I_demand", 1, 2, 0,\
 132)
DeclareAlias2("OCV.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "OCV_out", 1, 3, 1, 0)
DeclareAlias2("OCV.i", "Current flowing from pin p to pin n [A]", "I_demand", -1,\
 2, 0, 0)
DeclareAlias2("R1.v", "Voltage drop between the two pins (= p.v - n.v) [V]", \
"C1.vinternal", 1, 1, 1, 0)
DeclareVariable("R1.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("R1.p.v", "Potential at the pin [V]", "R0.n.v", 1, 5, 1, 4)
DeclareAlias2("R1.p.i", "Current flowing into the pin [A]", "R1.i", 1, 5, 3, 132)
DeclareVariable("R1.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("R1.n.i", "Current flowing into the pin [A]", "R1.i", -1, 5, 3, 132)
DeclareParameter("R1.R", "Resistance [Ohm]", 1, 0.0047, 0.0,0.0,0.0,0,560)
DeclareVariable("C2.v", "Voltage drop between the two pins (= p.v - n.v) [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("C2.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("C2.p.v", "Potential at the pin [V]", "R1.n.v", 1, 5, 4, 4)
DeclareAlias2("C2.p.i", "Current flowing into the pin [A]", "C2.i", 1, 5, 6, 132)
DeclareAlias2("C2.n.v", "Potential at the pin [V]", "V_cell_out", 1, 3, 0, 4)
DeclareAlias2("C2.n.i", "Current flowing into the pin [A]", "C2.i", -1, 5, 6, 132)
DeclareParameter("C2.C", "Capacitance [F]", 2, 2932.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("C2.IC", "Initial value [V]", 3, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("C2.UIC", "Use initial conditions: true, if initial condition is used [:#(type=Boolean)]",\
 4, false, 0.0,0.0,0.0,0,562)
DeclareState("C2.vinternal", "[V]", 0, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("C2.der(vinternal)", "[V/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("R2.v", "Voltage drop between the two pins (= p.v - n.v) [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("R2.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("R2.p.v", "Potential at the pin [V]", "R1.n.v", 1, 5, 4, 4)
DeclareAlias2("R2.p.i", "Current flowing into the pin [A]", "R2.i", 1, 5, 8, 132)
DeclareAlias2("R2.n.v", "Potential at the pin [V]", "V_cell_out", 1, 3, 0, 4)
DeclareAlias2("R2.n.i", "Current flowing into the pin [A]", "R2.i", -1, 5, 8, 132)
DeclareParameter("R2.R", "Resistance [Ohm]", 5, 0.0003, 0.0,0.0,0.0,0,560)
DeclareAlias2("currentSensor.p.v", "Potential at the pin [V]", "V_cell_out", 1, 3,\
 0, 4)
DeclareAlias2("currentSensor.p.i", "Current flowing into the pin [A]", \
"I_demand", 1, 2, 0, 132)
DeclareAlias2("currentSensor.n.v", "Potential at the pin [V]", "V_cell_out", 1, 3,\
 0, 4)
DeclareAlias2("currentSensor.n.i", "Current flowing into the pin [A]", \
"I_demand", -1, 2, 0, 132)
DeclareAlias2("currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "I_demand", 1, 2, 0, 0)
DeclareVariable("C1.v", "Voltage drop between the two pins (= p.v - n.v) [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("C1.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("C1.p.v", "Potential at the pin [V]", "R0.n.v", 1, 5, 1, 4)
DeclareAlias2("C1.p.i", "Current flowing into the pin [A]", "C1.i", 1, 5, 10, 132)
DeclareAlias2("C1.n.v", "Potential at the pin [V]", "R1.n.v", 1, 5, 4, 4)
DeclareAlias2("C1.n.i", "Current flowing into the pin [A]", "C1.i", -1, 5, 10, 132)
DeclareParameter("C1.C", "Capacitance [F]", 6, 180000.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("C1.IC", "Initial value [V]", 7, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("C1.UIC", "Use initial conditions: true, if initial condition is used [:#(type=Boolean)]",\
 8, false, 0.0,0.0,0.0,0,562)
DeclareState("C1.vinternal", "[V]", 1, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("C1.der(vinternal)", "[V/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("LoadCurrent.p.v", "Potential at the pin [V]", "V_cell_out", 1, 3,\
 0, 4)
DeclareAlias2("LoadCurrent.p.i", "Current flowing into the pin [A]", "I_demand", 1,\
 2, 0, 132)
DeclareVariable("LoadCurrent.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareAlias2("LoadCurrent.n.i", "Current flowing into the pin [A]", "I_demand", -1,\
 2, 0, 132)
DeclareAlias2("LoadCurrent.v", "Voltage drop between the two pins (= p.v - n.v) [V]",\
 "V_cell_out", 1, 3, 0, 0)
DeclareAlias2("LoadCurrent.i", "Current flowing from pin p to pin n as input signal [A]",\
 "I_demand", 1, 2, 0, 0)
DeclareVariable("ground.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("ground.p.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,\
0.0,0,777)
DeclareAlias2("V_OCV.p.v", "Potential at the pin [V]", "OCV_out", 1, 3, 1, 4)
DeclareVariable("V_OCV.p.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,\
0,777)
DeclareVariable("V_OCV.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("V_OCV.n.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,\
0,777)
DeclareAlias2("V_OCV.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "OCV_out", 1, 3, 1, 0)
DeclareAlias2("V_cell.p.v", "Potential at the pin [V]", "V_cell_out", 1, 3, 0, 4)
DeclareVariable("V_cell.p.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,\
0,777)
DeclareVariable("V_cell.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("V_cell.n.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,\
0,777)
DeclareAlias2("V_cell.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "V_cell_out", 1, 3, 0, 0)
DeclareVariable("DoD_OCV.nout", "Number of outputs [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("DoD_OCV.u", "Connector of Real input signal", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("DoD_OCV.y[1]", "Connector of Real output signals [V]", "OCV_out", 1,\
 3, 1, 0)
DeclareVariable("DoD_OCV.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("DoD_OCV.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 9, true, 0.0,0.0,0.0,0,562)
DeclareVariable("DoD_OCV.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("DoD_OCV.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,517)
DeclareVariable("DoD_OCV.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("DoD_OCV.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("columb_Counting.DoD", "", "DoD_OCV.u", 1, 5, 21, 0)
DeclareAlias2("columb_Counting.Iload_A", "[A]", "I_demand", 1, 2, 0, 0)
DeclareAlias2("columb_Counting.SoC", "", "SoC_out", 1, 3, 3, 0)
DeclareParameter("columb_Counting.integrator.k", "Integrator gain [1]", 10, 1, \
0.0,0.0,0.0,0,560)
DeclareVariable("columb_Counting.integrator.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("columb_Counting.integrator.y_start", "Initial or guess value of output (= state) [C]",\
 11, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("columb_Counting.integrator.u", "Connector of Real input signal [A]",\
 "I_demand", 1, 2, 0, 0)
DeclareState("columb_Counting.integrator.y", "Connector of Real output signal [C]",\
 2, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("columb_Counting.integrator.der(y)", "der(Connector of Real output signal) [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("columb_Counting.division.u1", "Connector of Real input signal 1 [C]",\
 "columb_Counting.integrator.y", 1, 1, 2, 0)
DeclareVariable("columb_Counting.division.u2", "Connector of Real input signal 2",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("columb_Counting.division.y", "Connector of Real output signal", \
"DoD_OCV.u", 1, 5, 21, 0)
DeclareAlias2("columb_Counting.Qtyp_Ah", "Typical Capacity of cell in Amp-hour",\
 "Ah_design.k", 1, 7, 16, 0)
DeclareAlias2("columb_Counting.add.u1", "Connector of Real input signal 1", \
"DoD_OCV.u", 1, 5, 21, 0)
DeclareAlias2("columb_Counting.add.u2", "Connector of Real input signal 2", \
"columb_Counting.const.k", 1, 7, 14, 0)
DeclareAlias2("columb_Counting.add.y", "Connector of Real output signal", \
"SoC_out", 1, 3, 3, 0)
DeclareParameter("columb_Counting.add.k1", "Gain of upper input", 12, -1, \
0.0,0.0,0.0,0,560)
DeclareParameter("columb_Counting.add.k2", "Gain of lower input", 13, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("columb_Counting.const.k", "Constant output value", 14, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("columb_Counting.const.y", "Connector of Real output signal", \
"columb_Counting.const.k", 1, 7, 14, 0)
DeclareParameter("columb_Counting.gain.k", "Gain value multiplied with input signal [1]",\
 15, 3600, 0.0,0.0,0.0,0,560)
DeclareAlias2("columb_Counting.gain.u", "Input signal connector", "Ah_design.k", 1,\
 7, 16, 0)
DeclareAlias2("columb_Counting.gain.y", "Output signal connector", \
"columb_Counting.division.u2", 1, 5, 28, 0)
DeclareOutput("V_cell_out", "[V]", 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareInput("I_demand", "[A:#(prefix=input)]", 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("Ah_design.k", "Constant output value", 16, 16.8, 0.0,0.0,0.0,0,560)
DeclareAlias2("Ah_design.y", "Connector of Real output signal", "Ah_design.k", 1,\
 7, 16, 0)
DeclareOutput("OCV_out", "[V]", 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("I_cell_out", "[A]", 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("SoC_out", "", 3, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,3), 0.0, 0);
DoRemember_(DYNX(W_,8), 0.0, 2);
DoRemember_(DYNX(F_,1), 0.0, 1);
DoRemember_(DYNX(F_,0), 0.0, 3);
EndEqBlock
EndDataBlock
